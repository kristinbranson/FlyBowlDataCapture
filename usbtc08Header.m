function [methodinfo,structs,enuminfo,ThunkLibName]=usbtc08Header
%USBTC08HEADER Create structures to define interfaces found in 'usbtc08'.

%This function was generated by loadlibrary.m parser version 1.1.6.36 on Thu Dec  5 13:33:02 2013
%perl options:'usbtc08.i -outfile=usbtc08Header.m -thunkfile=usbtc08_thunk_pcwin64.c -header=usbtc08.h'
ival={cell(1,0)}; % change 0 to the actual number of functions to preallocate the data.
structs=[];enuminfo=[];fcnNum=1;
fcns=struct('name',ival,'calltype',ival,'LHS',ival,'RHS',ival,'alias',ival,'thunkname', ival);
MfilePath=fileparts(mfilename('fullpath'));
ThunkLibName=fullfile(MfilePath,'usbtc08_thunk_pcwin64');
% short usb_tc08_set_channel ( short handle , short channel , char tc_type ); 
fcns.thunkname{fcnNum}='int16int16int16int8Thunk';fcns.name{fcnNum}='usb_tc08_set_channel'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int16', 'int16', 'int8'};fcnNum=fcnNum+1;
% long usb_tc08_run ( short handle , long interval_ms ); 
fcns.thunkname{fcnNum}='longint16longThunk';fcns.name{fcnNum}='usb_tc08_run'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='long'; fcns.RHS{fcnNum}={'int16', 'long'};fcnNum=fcnNum+1;
% long usb_tc08_get_temp ( short handle , float * temp_buffer , long * times_ms_buffer , long buffer_length , short * overflow , short channel , short units , short fill_missing ); 
fcns.thunkname{fcnNum}='longint16voidPtrvoidPtrlongvoidPtrint16int16int16Thunk';fcns.name{fcnNum}='usb_tc08_get_temp'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='long'; fcns.RHS{fcnNum}={'int16', 'singlePtr', 'longPtr', 'long', 'int16Ptr', 'int16', 'int16', 'int16'};fcnNum=fcnNum+1;
% long usb_tc08_get_temp_deskew ( short handle , float * temp_buffer , long * times_ms_buffer , long buffer_length , short * overflow , short channel , short units , short fill_missing ); 
fcns.thunkname{fcnNum}='longint16voidPtrvoidPtrlongvoidPtrint16int16int16Thunk';fcns.name{fcnNum}='usb_tc08_get_temp_deskew'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='long'; fcns.RHS{fcnNum}={'int16', 'singlePtr', 'longPtr', 'long', 'int16Ptr', 'int16', 'int16', 'int16'};fcnNum=fcnNum+1;
% short usb_tc08_get_single ( short handle , float * temp , short * overflow_flags , short units ); 
fcns.thunkname{fcnNum}='int16int16voidPtrvoidPtrint16Thunk';fcns.name{fcnNum}='usb_tc08_get_single'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int16', 'singlePtr', 'int16Ptr', 'int16'};fcnNum=fcnNum+1;
% short usb_tc08_open_unit ( void ); 
fcns.thunkname{fcnNum}='int16voidThunk';fcns.name{fcnNum}='usb_tc08_open_unit'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
% short usb_tc08_open_unit_async ( void ); 
fcns.thunkname{fcnNum}='int16voidThunk';fcns.name{fcnNum}='usb_tc08_open_unit_async'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
% short usb_tc08_open_unit_progress ( short * handle , short * percent_progress ); 
fcns.thunkname{fcnNum}='int16voidPtrvoidPtrThunk';fcns.name{fcnNum}='usb_tc08_open_unit_progress'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int16Ptr', 'int16Ptr'};fcnNum=fcnNum+1;
% short usb_tc08_close_unit ( short handle ); 
fcns.thunkname{fcnNum}='int16int16Thunk';fcns.name{fcnNum}='usb_tc08_close_unit'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int16'};fcnNum=fcnNum+1;
% short usb_tc08_stop ( short handle ); 
fcns.thunkname{fcnNum}='int16int16Thunk';fcns.name{fcnNum}='usb_tc08_stop'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int16'};fcnNum=fcnNum+1;
% short usb_tc08_set_mains ( short handle , short sixty_hertz ); 
fcns.thunkname{fcnNum}='int16int16int16Thunk';fcns.name{fcnNum}='usb_tc08_set_mains'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int16', 'int16'};fcnNum=fcnNum+1;
% long usb_tc08_get_minimum_interval_ms ( short handle ); 
fcns.thunkname{fcnNum}='longint16Thunk';fcns.name{fcnNum}='usb_tc08_get_minimum_interval_ms'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='long'; fcns.RHS{fcnNum}={'int16'};fcnNum=fcnNum+1;
% short usb_tc08_get_unit_info ( short handle , USBTC08_INFO * info ); 
fcns.thunkname{fcnNum}='int16int16voidPtrThunk';fcns.name{fcnNum}='usb_tc08_get_unit_info'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int16', 'tUSBTC08InfoPtr'};fcnNum=fcnNum+1;
% short usb_tc08_get_unit_info2 ( short handle , char * string , short string_length , short line ); 
fcns.thunkname{fcnNum}='int16int16cstringint16int16Thunk';fcns.name{fcnNum}='usb_tc08_get_unit_info2'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int16', 'cstring', 'int16', 'int16'};fcnNum=fcnNum+1;
% short usb_tc08_get_formatted_info ( short handle , char * unit_info , short string_length ); 
fcns.thunkname{fcnNum}='int16int16cstringint16Thunk';fcns.name{fcnNum}='usb_tc08_get_formatted_info'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int16', 'cstring', 'int16'};fcnNum=fcnNum+1;
% short usb_tc08_get_last_error ( short handle ); 
fcns.thunkname{fcnNum}='int16int16Thunk';fcns.name{fcnNum}='usb_tc08_get_last_error'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int16'};fcnNum=fcnNum+1;
% short usb_tc08_apply_fix ( unsigned long fixNo , unsigned short value ); 
fcns.thunkname{fcnNum}='int16ulonguint16Thunk';fcns.name{fcnNum}='usb_tc08_apply_fix'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'ulong', 'uint16'};fcnNum=fcnNum+1;
% short usb_tc08_legacy_run ( short handle ); 
fcns.thunkname{fcnNum}='int16int16Thunk';fcns.name{fcnNum}='usb_tc08_legacy_run'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int16'};fcnNum=fcnNum+1;
% short usb_tc08_legacy_set_channel ( short handle , short channel , char tc_type , short filter_factor , short offset , short slope ); 
fcns.thunkname{fcnNum}='int16int16int16int8int16int16int16Thunk';fcns.name{fcnNum}='usb_tc08_legacy_set_channel'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int16', 'int16', 'int8', 'int16', 'int16', 'int16'};fcnNum=fcnNum+1;
% short usb_tc08_legacy_get_temp ( long * temp , short handle , unsigned short channel , unsigned short filtered ); 
fcns.thunkname{fcnNum}='int16voidPtrint16uint16uint16Thunk';fcns.name{fcnNum}='usb_tc08_legacy_get_temp'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'longPtr', 'int16', 'uint16', 'uint16'};fcnNum=fcnNum+1;
% short usb_tc08_legacy_get_cold_junction ( long * temp , short handle ); 
fcns.thunkname{fcnNum}='int16voidPtrint16Thunk';fcns.name{fcnNum}='usb_tc08_legacy_get_cold_junction'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'longPtr', 'int16'};fcnNum=fcnNum+1;
% short usb_tc08_legacy_get_driver_version ( void ); 
fcns.thunkname{fcnNum}='int16voidThunk';fcns.name{fcnNum}='usb_tc08_legacy_get_driver_version'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
% short usb_tc08_legacy_get_version ( short * version , short handle ); 
fcns.thunkname{fcnNum}='int16voidPtrint16Thunk';fcns.name{fcnNum}='usb_tc08_legacy_get_version'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int16Ptr', 'int16'};fcnNum=fcnNum+1;
% short usb_tc08_legacy_get_cycle ( long * cycle , short handle ); 
fcns.thunkname{fcnNum}='int16voidPtrint16Thunk';fcns.name{fcnNum}='usb_tc08_legacy_get_cycle'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'longPtr', 'int16'};fcnNum=fcnNum+1;
structs.tUSBTC08Info.members=struct('size', 'int16', 'DriverVersion', 'int8#12', 'PicoppVersion', 'int16', 'HardwareVersion', 'int16', 'Variant', 'int16', 'szSerial', 'int8#11', 'szCalDate', 'int8#9');
enuminfo.enUSBTC08Progress=struct('USBTC08_PROGRESS_FAIL',-1,'USBTC08_PROGRESS_PENDING',0,'USBTC08_PROGRESS_COMPLETE',1);
enuminfo.enUSBTC08Units=struct('USBTC08_UNITS_CENTIGRADE',0,'USBTC08_UNITS_FAHRENHEIT',1,'USBTC08_UNITS_KELVIN',2,'USBTC08_UNITS_RANKINE',3,'USBTC08_MAX_UNITS',3);
enuminfo.enUSBTC08Error=struct('USBTC08_ERROR_OK',0,'USBTC08_ERROR_OS_NOT_SUPPORTED',1,'USBTC08_ERROR_NO_CHANNELS_SET',2,'USBTC08_ERROR_INVALID_PARAMETER',3,'USBTC08_ERROR_VARIANT_NOT_SUPPORTED',4,'USBTC08_ERROR_INCORRECT_MODE',5,'USBTC08_ERROR_ENUMERATION_INCOMPLETE',6,'USBTC08_ERROR_NOT_RESPONDING',7,'USBTC08_ERROR_FW_FAIL',8,'USBTC08_ERROR_CONFIG_FAIL',9,'USBTC08_ERROR_NOT_FOUND',10,'USBTC08_ERROR_THREAD_FAIL',11,'USBTC08_ERROR_PIPE_INFO_FAIL',12,'USBTC08_ERROR_NOT_CALIBRATED',13,'USBTC08_EROOR_PICOPP_TOO_OLD',14,'USBTC08_ERROR_PICOPP_TOO_OLD',14,'USBTC08_ERROR_COMMUNICATION',15);
enuminfo.enUSBTC08InfoLine=struct('USBTC08LINE_DRIVER_VERSION',0,'USBTC08LINE_KERNEL_DRIVER_VERSION',1,'USBTC08LINE_HARDWARE_VERSION',2,'USBTC08LINE_VARIANT_INFO',3,'USBTC08LINE_BATCH_AND_SERIAL',4,'USBTC08LINE_CAL_DATE',5);
enuminfo.enUSBTC08Channels=struct('USBTC08_CHANNEL_CJC',0,'USBTC08_CHANNEL_1',1,'USBTC08_CHANNEL_2',2,'USBTC08_CHANNEL_3',3,'USBTC08_CHANNEL_4',4,'USBTC08_CHANNEL_5',5,'USBTC08_CHANNEL_6',6,'USBTC08_CHANNEL_7',7,'USBTC08_CHANNEL_8',8,'USBTC08_MAX_CHANNELS',8);
methodinfo=fcns;